.. SPDX-License-Identifier: GPL-2.0

=======
VMGENID
=======

The VM Generation ID (VMGENID) is a feature from Microsoft
(https://go.microsoft.com/fwlink/?LinkId=260709) supported by multiple
hypervisor vendors.

Its purpose is to help tackle issues occurying by duplication of the state
of a Virtual Machine (VM) during events that cause a VM to "return back in
time", like snapshot and restore. It exposes a generation ID inside the VM so
that applications that rely on world-wide unique or random data can check if
that value has changed before committing transactions.

Problem Definition
------------------

Often in its lifetime, a VM will get snapshotted and later it will be restored
in that previous state. Moreover, one or more new VMs can be spawned from this
snapshot. Both scenarios result in one or more VMs running with same RNG state,
which makes early operations after restore that rely on randomness predictable,
and thus render them insecure, for example TLS.

Userspace PRNGs, as well as code that caches streams of random bits, to speed
up latency critical applications, suffer from similar issues.

Apart from concerns related with cryptography, userspace applications operating
with (what they consider to be) unique data, such as UUIDs, are affected by
spawning of multiple VMs from the same snapshot.

VMGENID tackles the issue by providing a unique (not random) 128-bits
identifier every time a VM is restored from a snapshot. The identifier is used
to reseed the kernel's RNG ensuring that different VMs spawned from the same
snapshot will observe different streams of random data.

Notice that VMGENID does not eliminate the problem but it significantly reduces
the window in which the system's RNG will produce identical data across
different VMs.

Reseeding the kernel's RNG tackles the issue of duplicated random values
provided by the kernel, however it does little to address the issue of
userspace applications that use world-unique data. The UUID defined by the
original VMGENID specification is used to reseed the RNG, so it cannot be
exposed to the userspace. This class of applications need a separate API which
they can consume in order to detect VM restore events and adapt accordingly.

In that front, VMGENID has been extended to expose to userspace an additional
32 bits generation counter, which acts as a notification mechanism for restore
events. The value of the counter after a VM restore will be different than
its value when the snapshot was taken in order to signal to userspace that
a VM restore has occured. 

VMGENID in Linux
----------------

Linux kernel uses the 128-bits UUID of VMGENID to reseed the RNG every time an
ACPI notification arrives. Moreover, it exposes the 32-bits generation counter
through a character device ``/dev/vmgenid``. The device supports ``read()``
and ``mmap`` for user space applications to monitor restore events:

``read()``:
Read always returns the first 4 bytes of the page including the generation
counter. Partial reads and reads in offset other than 0 are not allowed and
return ``EINVAL``.

``mmap()``:
It maps a single page in the address space of the userspace application. The
driver supports ``PROT_READ`` and ``MAP_SHARED``. Mapping with ``PROT_WRITE``
will result in ``EPERM``, whereas mapping past the first page will result in
``EINVAL``.

A userspace application that caches random bits from the kernel should ensure
that the moment it actually wants to consume some of these bits the value of
the generation counter equals its value when the bits were initially cached.
For example:

```
uint32_t *gen_cntr = mmaped_gen_counter();
uint32_t cached_gen_cntr = *gen_cntr;
char *secret;

for(;;) {
    secret = get_secret();

    // All good, not restore has happened.
    if (cached_gen_cntr == *gen_cntr)
        break;

    // Generation counter has changed. We need to recreate caches and try again

    cached_gen_cntr = *gen_cntr;
    barrier();

    // recreate secrets' cache
    rebuild_cache();
}

consume_secret(secret);

```

The driver for VMGENID lives under ``drivers/virt/vmgenid.c``.

Using VMGENID
-------------

https://git.qemu.org/?p=qemu.git;a=blob_plain;f=docs/specs/vmgenid.txt;hb=refs/heads/master
describes how the VMGENID device can be used. First we start a VM passing the
parameter `-device vmgenid,guid=auto,genctr=42`. With this the UUID value of
VMGENID will be populated with a UUID created by qemu and a generation counter
of 42. Next, we can save the VM state from the monitor using the `savevm`
command.

Now, we can start another VM from the same snapshot using the `-device
vmgenid,guid=auto,genctr=43 -loadvm {snapshot}` options. This will update the
UUID with a new value generated by qemu and 43 for the generation counter in
memory before resuming the vcpus and then send an appropriate ACPI notification
to the guest.
